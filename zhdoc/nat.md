# 自然数

`Nat` 类型表示自然数，即任意精度的无符号整数。
不会发生溢出。

```lean
#eval 100000000000000000 * 200000000000000000000 * 1000000000000000000000
```

如果没有任何类型约束，一个数字常数被认为是 `Nat` 类型。

```lean
#check 10    -- Nat
#check id 10 -- Nat

def f (x : Int) : Int :=
  x - 1

#eval f (3 - 5) -- 3 and 5 are `Int` since `f` expects an `Int`.
-- -3
```

`Nat`类型的运算符`-`实现了截断减法。



```lean
#eval 10 - 5 -- 5
#eval 5 - 10 -- 0

theorem ex : 5 - 10 = 0 :=
  rfl

#eval (5:Int) - 10 -- -5
```

对于 `Nat` 类型的运算符 `/` 实现了欧几里得除法。

```lean
#eval 10 / 4 -- 2

#check 10.0 / 4.0 -- Float
#eval 10.0 / 4.0  -- 2.5
```

正如我们在前面的部分中所描述的，我们将 `Nat` 类型定义为一个归纳数据类型。

```lean
# namespace hidden
inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
# end hidden
```

然而，`Nat` 类型的内部表示经过了优化。小的自然数（即在64位机器上小于 `2^63`）用一个机器字表示。大数则使用[GMP](https://gmplib.org/manual/)库来实现。我们建议您只在性能关键的代码中使用固定精度数值类型。

Lean 内核也对 `Nat` 类型提供了内置支持，并且在类型检查期间可以高效地简化 `Nat` 表达式。

```lean
#reduce 100000000000000000 * 200000000000000000000 * 1000000000000000000000

theorem ex
      : 1000000000000000 * 2000000000000000000 = 2000000000000000000000000000000000 :=
  rfl
```

敏锐的读者会注意到GMP是 Lean 内核可信代码库的一部分。
我们认为这不是一个问题，因为您可以使用外部类型检查器来对开发进行双重检查，
而且我们认为 GMP 是非常可信赖的。
现有的 Lean 3 的外部类型检查器（例如 [Trepplein](https://github.com/gebner/trepplein) 和 [TC](https://github.com/leanprover/tc)）
可以很容易地适应 Lean 4。
如果您在使用多个不同的外部检查器检查开发后仍然感到担心，
因为它们可能都依赖有错误的任意精度库，
您可以开发自己的认证任意精度库，并使用它来实现您自己的 Lean 类型检查器。