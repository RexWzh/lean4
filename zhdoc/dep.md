## 让依赖类型论变得依赖的是什么？

简单来说，让依赖类型论变得依赖的是类型可以依赖于参数。
你已经看到一个很好的例子：类型 `List α` 依赖于参数 `α`，这种依赖关系使得 `List Nat` 和 `List Bool` 有所区别。
再来看一个例子，考虑类型 `Vector α n`，它是由长度为 `n` 的 `α` 类型元素构成的向量类型。
这个类型依赖于**两个**参数：向量中元素的类型 `α: Type` 和长度 `n : Nat`。

假设我们希望编写一个函数 `cons`，它在列表的开头插入一个新元素。
那么 `cons` 应该有什么类型呢？这样的函数是**多态的**：我们希望 `Nat`、`Bool` 或者任意类型 `α` 的 `cons` 函数的行为是相同的。
因此，将类型作为 `cons` 的第一个参数是有意义的，这样对于任何类型 `α`，`cons α` 就是列表类型 `α` 的插入函数。换句话说，对于每个 `α`，`cons α` 是一个函数，
它接受一个元素 `a : α` 和一个列表 `as : List α`，并返回一个新的列表，即 `cons α a as : list α`。

很明显，`cons α` 的类型应该是 `α → List α → List α`。但是 `cons` 的类型应该是什么呢？
初步猜测可能是 `Type → α → list α → list α`，但是仔细思考后发现这不合理：
这个表达式中的 `α` 没有指代任何东西，而应该指代类型 `Type` 的参数。
换句话说，**假设** `α : Type` 是函数的第一个参数，接下来的两个元素的类型分别是 `α` 和 `List α`。
这些类型根据第一个参数 `α` 的不同而变化。

这是一个*依赖函数类型*或*依赖箭头类型*的实例。给定 `α : Type` 和 `β : α → Type`，
可以将 `β` 视为一个在 `α` 上的类型族，也就是说，对于每个 `a : α`，有一个类型 `β a`。
在这种情况下，`(a : α) → β a` 表示具有特定属性的函数 `f` 的类型，
对于每个``a：α``，``f a``都是``β a``的一个元素。换句话说，函数``f``返回的值的类型取决于其输入。

需要注意的是，对于任何``β：Type``的表达式，``(a：α) → β``都是有意义的。当``β``的值取决于``a``（例如上文中的表达式``β a``），``(a：α) → β``表示一个依赖函数类型。当``β``不取决于``a``时，``(a：α) → β``与类型``α → β``没有区别。事实上，在依赖类型理论（和Lean中），当``β``不依赖``a``时，``α → β``只是``(a：α) → β``的一种记法。

回到列表的例子，我们可以使用``#check``命令来检查以下``List``函数的类型。稍后我们将解释``@``符号和圆括号与花括号的区别。

```lean
#check @List.cons    -- {α : Type u_1} → α → List α → List α
#check @List.nil     -- {α : Type u_1} → List α
#check @List.length  -- {α : Type u_1} → List α → Nat
#check @List.append  -- {α : Type u_1} → List α → List α → List α
```

就像依赖的函数类型 ``(a : α) → β a`` 通过允许 ``β`` 依赖于 ``α`` 来概括函数类型 ``α → β`` 的概念一样，依赖的笛卡尔积类型 ``(a : α) × β a`` 以相同的方式概括了笛卡尔积 ``α × β`` 。依赖的积类型也被称为 *sigma* 类型，你也可以将它们写为 `Σ a : α, β a`。你可以使用 `⟨a, b⟩` 或 `Sigma.mk a b` 来创建一个依赖的对（dependent pair）。

```lean
universe u v

def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=
  ⟨a, b⟩

def g (α : Type u) (β : α → Type v) (a : α) (b : β a) : Σ a : α, β a :=
  Sigma.mk a b

#reduce f
#reduce g

#reduce f Type (fun α => α) Nat 10
#reduce g Type (fun α => α) Nat 10

#reduce (f Type (fun α => α) Nat 10).1 -- Nat
#reduce (g Type (fun α => α) Nat 10).1 -- Nat
#reduce (f Type (fun α => α) Nat 10).2 -- 10
#reduce (g Type (fun α => α) Nat 10).2 -- 10
```

上述的 `f` 和 `g` 函数表示相同的函数。